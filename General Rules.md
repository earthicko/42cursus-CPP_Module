# 공통 규칙

## 컴파일

- `c++`로 컴파일하고 플래그 `-Wall -Wextra -Werror`를 준다.
- `-std=c++98` 플래그를 추가해도 컴파일 되어야 한다.

### 서식 및 이름 짓기

- N번 예제의 디렉토리 이름은 `ex0N`으로 짓는다.
- 가이드라인에 명시된대로 파일, 클라스, 함수, 멤버 함수, 속성의 이름을 짓는다.
- UpperCamelCase 형식대로 클라스 이름을 짓는다. 클라스의 코드를 포함하는 파일도 이 규칙을 따라 명명해야 한다. (예: `ClassName.hpp`, `ClassName.cpp`)
- 별다른 지시 사항이 없을 시 모든 출력 구문은 개행 문자로 끝나고 표준 출력에 출력되어야 한다.
- C++ 모듈에서는 특별한 코딩 스타일이 요구되지 않는다. 하지만 동료가 평가하기 용이하도록 깔끔하고 가독성이 뛰어나게 작성한다.

### 허용 / 금지 사항

- 표준 라이브러리에 있는 거의 모든 것을 사용할 수 있다. 따라서 이미 알고 있는 기능을 활용하기보다는 기존 C 함수의 C++다운 버젼을 활용하는 것이 바람직하다.
- 그러나 외부 라이브러리는 사용할 수 없다. 따라서 C++11 및 그 파생형, Boost 라이브러리는 사용할 수 없다.
  - `*printf()`, `*alloc()`, `free()`를 사용할 수 없다.
  - 별다른 지시 사항이 없을 시 `using namespace <ns_name>`과 `friend` 키워드는 사용할 수 없다.
  - STL은 모듈 08에서만 사용할 수 있다. 따라서 컨테이너 (벡터, 리스트, 맵 등) 및 알고리듬 (`<algorithm>` 헤더를 필요로 하는 모든 것)은 사용할 수 없다.

## 몇몇 디자인 요구사항

- 메모리 누수는 C++에서도 일어난다. `new` 키워드를 사용해 메모리를 할당할 때는 반드시 메모리 누수를 방지해야 한다.
- 모듈 02부터 모듈 08까지 별다른 지시 사항이 없는 한 반드시 클라스를 정석 (Orthodox Canonical Form)적으로 작성해야 한다.
- 함수 템플릿을 제외하고 헤더 파일에 함수의 구현 부분을 작성해서는 안 된다.
- 헤더 파일을 독립적으로 사용할 수 있어야 한다. 즉 헤더 파일은 필요한 모든 의존성 정보를 포함해야 한다. 단 중복 인클루드를 방지하기 위해 인클루드 가드를 작성해야 한다.

## 참고 사항

- 코드를 분리하는 등의 목적을 위해 파일을 임의로 추가할 수 있다. 이 과제는 프로그램이 평가하지 않으므로 필수 요구 파일을 올바르게 제출했다는 전제 하에 이러한 파일을 자유롭게 추가할 수 있다.
- 때때로 예제의 지침은 간단해 보이지만 지침에 명시된 지시 사항 외의 암시적인 요구 사항이 예시에 포함되어 있을 수 있다.

> 이 과제를 수행할 때는 어느 정도의 자율성이 보장된다. 그러나 필수적으로 요구되는 사항은 반드시 완수하고 해이해지지 말라. 이론적인 개념을 탐독하라.
